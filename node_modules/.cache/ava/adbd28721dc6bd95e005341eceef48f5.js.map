{"version":3,"sources":["mergeSort.js"],"names":["test","require","split","arr","size","Math","floor","length","slice","merge","arr1","arr2","ret","i","j","console","log","push","only","act","exp","t","deepEqual","mergeSort","left","right","array"],"mappings":"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","file":"mergeSort.js","sourcesContent":["/*\nMERGE SORT\n*** Description\nMerge sort employs a divide and conquer strategy - merge two sorted subarrays into one sorted array.\nRecursive top-down approach:\nRecursively break down array into two subarrays and sort them recursively. Subarrays are broken down until they have only 1 element (implying they are sorted).\nIterative bottom-up approach:\nSplit array into sublists of size 1, merge adjacent sublists into sorted lists, repeat until no more sublists.\n*** Exercises\n- Implement recursive merge sort (you might want to write a helper function to handle the merge step)\n- Implement iterative merge sort\n- Identify time complexity\n- Modify function to take comparator function. specify default if not provided (check out native Array.sort comparator function for reference)\n- Use your comparator function to verify that your sort is stable by taking input: [{value: 15}, {value: 10, order: 1}, {value: 10, order: 2}]\nOptimization:\n- Refactor your iterative solution to be a natural merge sort. This means that the initial subarrays are naturally occurring sorted sequences. How does this impact time complexity and adaptivity?\nex:\ninput array: [ 1 2 4 5 9 ]\nsubarrays for regular merge sort: [ [1], [2], [4], [5], [9] ]\nsubarrays for natural merge sort: [ [1,2], [4,5], [9] ]\n*/\nvar test = require('ava')\n\nfunction split (arr) {\n    var size = Math.floor(arr.length / 2)\n    return [arr.slice(0, size), arr.slice(size)]\n}\n\n// takes two sorted arrays\nfunction merge (arr1, arr2) {\n    const ret = []\n\n    for ( let i = 0 , j = 0; i < arr1.length && j < arr2.length; ) {\n        console.log(arr1[i], i < arr1.length, arr2[j], j < arr2.length, i < arr1.length && j < arr2.length,)\n        if(  arr2[j] > arr1[i] ) {\n            ret.push(arr[i])\n            i++\n        }\n        else {\n            j++\n        }\n        ret.push(arr[j])\n        console.log(arr1[i], i < arr1.length, arr2[j], j < arr2.length, i < arr1.length && j < arr2.length,)\n    }\n    return ret\n}\ntest.only('merge two single el presorted arrays', t => {\n    const arr1 = [5]\n    const arr2 = [2]\n    const act = merge(arr1, arr2)\n    const exp = [2, 5]\n    t.deepEqual(act, exp)\n})\n\ntest('merge two presorted arrays', t => {\n    const arr1 = [2, 9, 24]\n    const arr2 = [5, 11 , 23, 48]\n    const act = merge(arr1, arr2)\n    const exp = [2, 5, 9, 11, 23, 24, 48]\n\n    t.deepEqual(act, exp)\n\n})\n\n\nfunction mergeSort (arr) {\n    if (arr.length < 2 ) {\n        return arr\n    }\n    else {\n        var [ left , right ] = split(arr)\n        return [ left , right ]\n    }\n}\n\ntest('split an array in two', t => {\n    var array = [ 1, 2, 4, 5, 9 ]\n    const act = split(array)\n    const exp = [ [1,2], [4,5,9] ]\n    t.deepEqual(act, exp)\n\n})\ntest('return if array len 1', t => {\n    var array = [ 1 ]\n    const act = mergeSort(array)\n    const exp = [ 1 ]\n    t.deepEqual(act, exp)\n\n})\n\ntest('split in 2 correctly', t => {\n    var array = [ 1, 2, 4, 5, 9 ]\n    const act = mergeSort(array)\n    const exp = [ [1,2], [4,5,9] ]\n    t.deepEqual(act, exp)\n})\n\ntest('sort correctly  when 2 left', t => {\n    var array = [ 1, 2, 4, 5, 9 ]\n    const act = mergeSort(array)\n    const exp = [ [1,2], [4,5,9] ]\n    t.deepEqual(act, exp)\n})\n\n"]}