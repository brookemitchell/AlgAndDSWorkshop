{"version":3,"sources":["linkedList.js"],"names":["test","require","Node","value","next","of","v","n","LinkedList","node","undefined","console","log","head","prototype","forEach","callback","list","act","e","exp","t","deepEqual","print","res","push","join","insertAfter","nodeNumber","newNode","index","removeAfter","insertHead","removeHead","findNode","appendToTail","insertBefore","removeBefore"],"mappings":"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","file":"linkedList.js","sourcesContent":["/*\nLINKED LIST\nComprised of nodes that represent a sequence.\nEach node is composed of data and a reference/link to the next node.\n*** Operations:\n** Part 1\nmyList.forEach(callbackFn)\ninvoke callback function with the value of each node\nmyList.print()\n=> string with all values in list (ex: '0, 1, 2, 3')\nmyList.insertAfter(refNode, value)\n=> new node\ninsert new node associated with value passed in after refNode\nmyList.removeAfter(refNode)\n=> removed node\nremove node after the refNode\nmyList.insertHead(value)\n=> new head\ninsert new head node at the beginning of the list with the value passed in\nmyList.removeHead()\n=> removed head node\nremove the head node of the linked list\nmyList.findNode(value)\n=> first node that has a value matching what was passed in\n* Optimization:\nSay we have a linked list that has 100 items and we want to add an item to the very end. How would you do that with your current implementation? How can you modify the data structure to add an item to the end in constant time?\nmyList.appendToTail(value)\n=> new tail node\nadd a new tail node at the end of the list with the associated value passed in\nmyList.removeTail()\n=> removed tail node\nremove the tail node from the list\n** Part 2\nNow let's think about creating insertBefore and removeBefore methods for the nodes in our list. Can you think of an efficient way to do so?\nThink about time complexity. What would it be for your current implementation of a linked list?\nHow can we modify our data structures (Node and Linked List classes) so that we can make these O(1) operations?\nOnce you've come up with a plan, implement the following methods.\nmyList.insertBefore(refNode, value)\n=> new node inserted\ninsert new node with associated value before refNode\nmyList.removeBefore(refNode)\n=> removed node\nremove node before the refNode passed in\n*** Additional Exercises:\nImplement a circularly linked list:\nhttps://en.wikipedia.org/wiki/Linked_list#Circularly_linked_list\nReimplement stack and queue data structures using linked lists.\n */\n\nvar test = require('ava')\n\n// PART 1\n\nfunction Node(value, next = null) {\n  this.next = next;\n  this.value = value;\n}\n\nNode.of = (v, n) => new Node(v, n)\n\nfunction LinkedList(node) {\n  if (node === undefined) console.log('Must provide value for first node');\n  this.head = node\n}\n\nLinkedList.prototype.forEach = function(callback) {\n  // implement me...\n    var next = this.head\n    while(next) {\n        next.value = callback(next.value)\n        next = next.next\n    }\n    return this.head\n};\n\ntest('maps correctly w one', t => {\n    var list = new LinkedList(Node.of(1))\n    var act = list.forEach(e => e * 2)\n    var exp = new Node(2)\n    t.deepEqual(act, exp)\n})\n\ntest('maps correctly w many', t => {\n    var list = new LinkedList(Node.of(1, Node.of(2, Node.of(99))))\n    var act = list.forEach(e => e * 2)\n    var exp = {next:{next:{next:null,value:198},value:4},value:2}\n    t.deepEqual(act, exp)\n})\n\n// Time complexity:\n\nLinkedList.prototype.print = function() {\n  // implement me...\n  var res = []\n  this.forEach(e => res.push(e))\n  return res.join(', ')\n};\n\ntest('prints', t => {\n    var list = new LinkedList(Node.of(1, Node.of(2, Node.of(99))))\n    var act = list.print()\n    var exp = '1, 2, 99'\n    t.deepEqual(act, exp)\n})\n// Time complexity: n\n\nLinkedList.prototype.insertAfter = function(nodeNumber, newNode) {\n  // implement me...\n  var index = 0\n  var node = this.head\n  while (node) {\n    if (nodeNumber === index) {\n      node.next = newNode\n    }\n    index += 1\n    node = node.next\n  }\n\n  return new LinkedList(this.head)\n};\ntest('inserts after n nodes', t => {\n  var list = new LinkedList(Node.of(1, Node.of(2, Node.of(99))))\n  var act = list.insertAfter(1, Node.of(3))\n  var exp = new LinkedList(Node.of(1, Node.of(2, Node.of(3, Node.of(99)))))\n  t.deepEqual(act, exp)\n})\n// Time complexity:\n\nLinkedList.prototype.removeAfter = function(node) {\n  // implement me...\n};\n// Time complexity:\n\nLinkedList.prototype.insertHead = function(value) {\n  // implement me...\n};\n// Time complexity:\n\nLinkedList.prototype.removeHead = function() {\n  // implement me...\n}\n\nLinkedList.prototype.findNode = function(value) {\n  // implement me...\n};\n// Time complexity:\n\nLinkedList.prototype.appendToTail = function(value) {\n  // implement me...\n};\n// Time complexity:\n\n\n// PART 2:\n\nLinkedList.prototype.insertBefore = function(node, value) {\n  // implement me...\n};\n// Time complexity:\n\nLinkedList.prototype.removeBefore = function(node) {\n  // implement me...\n};\n// Time complexity:\n\n\n\n/*\n*** Exercises:\n1. Implement a stack using a linked list.\n2. Implement a queue using a linked list.\n3. Write a method that remove duplicates from an unsorted linked list. What is the time complexity? Re-implement the method without using any additional storage structure (constant space complexity). What is the time complexity?\n4. Reverse a linked list. Do not use any additional storage structures.\n5. Find the kth to last element of a singly linked list.\n6. Detect if a linked list has a loop.\n7. Check if a linked list is a palindrome.\n8. Given two linked lists that represent numbers, return a linked list that represents the sum of those numbers:\n  4 2 5        (4 -> 2 -> 5)\n+ 7 3 1        (7 -> 3 -> 1)\n--------\n1 1 5 6   (1 -> 1 -> 5 -> 6)\n */\n"]}